## 1 事务的四大特性
原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
- 原子性：指事务包含的所有操作要么全部成功，要么全部失败回滚。
- 一致性：指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。
- 隔离性：指一个事务的执行不能被其他事务干扰。每个事务应该以一种对其他事务隔离的方式执行，以防止并发执行时可能出现的数据不一致问题。隔离性通过使用锁和事务的隔离级别来实现
- 持久性：指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

## 2 数据库三大范式
- 第一范式：要求表中的每一列都是不可再分的基本数据项，而且每一行都不可重复，确保表中的每个字段必须是原子的
- 第二范式：一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分
- 第三范式：非主键列必须直接依赖于主键，不能存在传递依赖

**2NF和3NF的区别**
- 2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。
- 3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。

## 3 事务隔离级别
先了解下几个概念：脏读、不可重复读、幻读。
- 脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- 不可重复读：指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。
- 幻读：指的是在同一事务中的两次查询之间，由于其他事务插入或删除了数据，导致第二次查询看到了一些之前不存在或已经被删除的记录，就好像发生了幻觉一样

**不可重复读和脏读的区别**是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

四种隔离级别
- 读未提交（Read Uncommitted）：一个事务可以读取到另一个事务未提交的数据变更，存在脏读、不可重复读和幻读等并发问题
- 读已提交（Read Committed）：一个事务只能读取到已经提交的数据变更，可能出现不可重复读和幻读的问题
- 可重复读（Repeatable Read）：一个事务在其生命周期内多次查询同一数据，都将得到相同的结果，能出现幻读的问题
- 串行化（Serializable）：事务之间完全隔离，为了达到这个目标，系统通常会使用锁来阻止其他事务访问已经被当前事务锁定的数据

## 4 索引
索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。它可以比作一本字典的目录，可以帮你快速找到对应的记录。

优点：加快数据查找的速度。 缺点：占用物理空间；会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引

## 5 索引的数据结构
B+树和哈希表
- 哈希索引不支持排序，因为哈希表是无序的。
- 哈希索引不支持范围查找。
- 哈希索引不支持模糊查询及多列索引的最左前缀匹配。
- 因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点

## 6 B+树比B树更适合实现数据库索引
- B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当
- B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。
- B+树叶子结点均为索引，方便扫库；B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫

## 7 InnoDB和MyISAM存储引擎
事务支持：
- MyISAM： 不支持事务。MyISAM表的操作是自动提交的，不提供事务的回滚和提交机制。
- InnoDB： 支持事务。InnoDB是一个支持ACID事务的存储引擎，具有事务的隔离级别，支持事务的回滚和提交。
行级锁定和并发性：
- MyISAM： 只支持表级锁定，因此在高并发读写的情况下，可能会发生较多的锁定冲突，降低并发性。
- InnoDB： 支持行级锁定，这使得在高并发环境下可以更好地处理多个事务同时进行读写操作。
外键约束：
- MyISAM： 不支持外键约束，即不支持FOREIGN KEY。
- InnoDB： 支持外键约束，可以保证数据的一致性和完整性。

## 8 MySQL有哪些锁
按锁粒度分类：
- 行级锁：只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大 。行级锁的类型主要有三类： 
  - Record Lock，记录锁，也就是仅仅把一条记录锁上；
  - Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
  - Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
- 页级锁：速度快，但冲突多，一次锁定相邻的一组记录
- 表级锁：粒度最大的一种锁，对当前操作的整张表加锁，它实现简单，资源消耗较少
按锁级别分类：
- 共享锁又称读锁：读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改
- 排他锁又称写锁：事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁
- 意向锁是表级锁：在一个事务中揭示下一行将要被请求锁的类型，InnoDB 中的两个表锁
   - 意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁
   - 意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

## 9 乐观锁和悲观锁
MySQL并发控制的策略。
- 悲观锁的思想是在整个数据操作过程中，将数据锁定，以防止其他事务的干扰。
- 乐观锁的思想是认为在大多数情况下，事务之间的冲突是很少发生的。因此，乐观锁不主动加锁，而是在事务提交时检查是否有其他事务对数据进行了修改
