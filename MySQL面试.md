## 1 事务的四大特性
原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
- 原子性：指事务包含的所有操作要么全部成功，要么全部失败回滚。
- 一致性：指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。
- 隔离性：指一个事务的执行不能被其他事务干扰。每个事务应该以一种对其他事务隔离的方式执行，以防止并发执行时可能出现的数据不一致问题。隔离性通过使用锁和事务的隔离级别来实现
- 持久性：指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

## 2 数据库三大范式
- 第一范式：要求表中的每一列都是不可再分的基本数据项，而且每一行都不可重复，确保表中的每个字段必须是原子的
- 第二范式：一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分
- 第三范式：非主键列必须直接依赖于主键，不能存在传递依赖

**2NF和3NF的区别**
- 2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。
- 3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。

## 3 事务隔离级别
先了解下几个概念：脏读、不可重复读、幻读。
- 脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- 不可重复读：指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。
- 幻读：指的是在同一事务中的两次查询之间，由于其他事务插入或删除了数据，导致第二次查询看到了一些之前不存在或已经被删除的记录，就好像发生了幻觉一样

**不可重复读和脏读的区别**是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

四种隔离级别
- 读未提交（Read Uncommitted）：一个事务可以读取到另一个事务未提交的数据变更，存在脏读、不可重复读和幻读等并发问题
- 读已提交（Read Committed）：一个事务只能读取到已经提交的数据变更，可能出现不可重复读和幻读的问题
- 可重复读（Repeatable Read）：一个事务在其生命周期内多次查询同一数据，都将得到相同的结果，能出现幻读的问题
- 串行化（Serializable）：事务之间完全隔离，为了达到这个目标，系统通常会使用锁来阻止其他事务访问已经被当前事务锁定的数据

## 4 索引
索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。它可以比作一本字典的目录，可以帮你快速找到对应的记录。

优点：加快数据查找的速度。 缺点：占用物理空间；会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引

数据结构：B+树和哈希表
- 哈希索引不支持排序，因为哈希表是无序的。
- 哈希索引不支持范围查找。
- 哈希索引不支持模糊查询及多列索引的最左前缀匹配。
- 因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点

索引类型

按照底层存储方式角度划分
- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引

按照应用维度划分
- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- **覆盖索引**：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- **联合索引**：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

## 5 B+树比B树更适合实现数据库索引
B树索引和B+树索引是两种在数据库系统中常见的索引结构，它们在设计和使用上有一些关键区别：

1. **节点结构：**
   - **B树：** B树的非叶子节点既包含键值信息，也包含对子节点的引用。每个节点的键值都与一个数据块相关联，可能直接指向存储数据的位置。
   - **B+树：** B+树的非叶子节点仅包含键值信息，而不包含实际数据。所有数据的地址都存储在叶子节点上，叶子节点通过链表连接。

2. **范围查询：**
   - **B树：** B树可以支持范围查询，因为键值直接关联着数据块的位置。范围查询时，B树可以在分支节点和叶子节点之间进行跳跃。
   - **B+树：** B+树通过叶子节点的有序链表优化范围查询，范围查询时只需要遍历叶子节点链表即可。

3. **叶子节点：**
   - **B树：** B树的叶子节点可能包含数据，也可能直接指向数据的位置。在B树中，叶子节点并不一定形成一个链表。
   - **B+树：** B+树的叶子节点包含所有数据，形成一个有序链表。这种结构方便范围查询和遍历整个表。

4. **查询效率：**
   - **B树：** B树在查找时可能需要在非叶子节点和叶子节点之间多次跳跃，导致更多的磁盘I/O操作。
   - **B+树：** B+树的查询效率相对较高，因为查询通常只涉及叶子节点，减少了磁盘I/O操作。

5. **插入和删除操作：**
   - **B树：** B树的插入和删除可能需要在树的中间进行调整，分裂或合并节点，以保持平衡性。
   - **B+树：** B+树的插入和删除通常只涉及叶子节点，不需要修改中间节点，因此更容易维护平衡。

6. **适用场景：**
   - **B树：** B树适用于需要支持范围查询，并且插入和删除操作相对较频繁的场景。
   - **B+树：** B+树适用于需要高效范围查询、遍历整个表的场景，特别是在外部存储中，如数据库索引。

## 6 聚簇索引与非聚簇索引
聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。查询速度非常快；依赖于有序的数据，更新代价大
非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。更新代价比聚簇索引要小；但是依赖于有序的数据，可能会二次查询（当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询）

## 7 最左前缀匹配原则
使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 >、< ）才会停止匹配。对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

## 8 MVCC（多版本并发控制方法）
对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本
- undo log : undo log 用于记录某行数据的多个版本的数据。
- read view 和 隐藏字段 : 用来判断当前版本数据的可见性。

## 9 MySQL有哪些锁
按锁粒度分类：
- 行级锁：只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大 。行级锁的类型主要有三类： 
  - Record Lock，记录锁，也就是仅仅把一条记录锁上；
  - Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
  - Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
- 页级锁：速度快，但冲突多，一次锁定相邻的一组记录
- 表级锁：粒度最大的一种锁，对当前操作的整张表加锁，它实现简单，资源消耗较少
按锁级别分类：
- 共享锁又称读锁：读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改
- 排他锁又称写锁：事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁
- 意向锁是表级锁：在一个事务中揭示下一行将要被请求锁的类型，InnoDB 中的两个表锁
   - 意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁
   - 意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

## 10 InnoDB和MyISAM存储引擎
InnoDB支持行级别的锁 提供事务支持 实现了 SQL 标准定义了四个隔离级别 支持外键 支持MVCC 是聚簇索引
- InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。
- MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。
- MyISAM 不支持外键，而 InnoDB 支持。
- MyISAM 不支持 MVCC，而 InnoDB 支持。
- 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。InnoDB是聚簇索引，MyISAM是非聚簇索引
- MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。InnoDB 的性能比 MyISAM 更强大


## 11 乐观锁和悲观锁
MySQL并发控制的策略
- 悲观锁的思想是在整个数据操作过程中，将数据锁定，以防止其他事务的干扰。
- 乐观锁的思想是认为在大多数情况下，事务之间的冲突是很少发生的。因此，乐观锁不主动加锁，而是在事务提交时检查是否有其他事务对数据进行了修改

## 12 MySQL字段类型
- 数值类型：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
- 字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
- 日期时间类型：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP

## 13 CHAR 和 VARCHAR 的区别
CHAR 是定长字符串，VARCHAR 是变长字符串

## 14 DECIMAL 和 FLOAT/DOUBLE 的区别
DECIMAL 和 FLOAT 的区别是：DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。

## 15 DATETIME 和 TIMESTAMP 的区别
DATETIME 类型没有时区信息，TIMESTAMP 和时区有关

## 16 Boolean 类型如何表示
MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值

## 17 NULL 和 '' 的区别（为什么 MySQL 不建议使用 NULL 作为列默认值）
- ''的长度是 0，是不占用空间的，而NULL 是需要占用空间的
- 查询 NULL 值时，必须使用 IS NULL 或 IS NOT NULLl 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而''是可以使用这些比较运算符的

## 18 SQL 优化
索引、JOIN、LIMIT

## 19 char varchar text区别
CHAR：
存储固定长度的字符数据。
如果存储的字符串长度小于指定的长度，将使用空格进行填充。
非变长，占用的存储空间是指定长度的固定大小。
```sql
CREATE TABLE example_char (
    char_column CHAR(10)
);
```
VARCHAR：
存储可变长度的字符数据。
只存储实际字符串的长度，不使用填充字符。
需要额外的存储空间来存储字符串的长度信息。
```sql
Copy code
CREATE TABLE example_varchar (
    varchar_column VARCHAR(255)
);
```
TEXT：
用于存储大量的文本数据，长度可以很大。
通常用于存储文档、文章或其他较大的文本块。
不需要指定固定的长度。
```sql
Copy code
CREATE TABLE example_text (
    text_column TEXT
);
```

## 20 char varchar text检索效率
CHAR：  
由于是固定长度，CHAR 类型的字段可能在某些情况下提供更快的检索速度。这是因为数据库引擎可以更容易地计算出每个记录的偏移量。
当查询涉及到固定长度的匹配时，CHAR 可能更为高效。

VARCHAR：  
VARCHAR 类型的字段存储实际的字符串长度，因此在存储和检索时可能需要更少的空间。  
VARCHAR 在处理可变长度的字符串时更灵活，但这也可能导致在某些情况下稍微降低检索速度。 

TEXT：  
TEXT 类型通常用于存储大块的文本数据，如文章或文档。在一些情况下，可能会牺牲一些检索速度以获取更大的存储容量。
对于 TEXT 类型，数据库引擎可能需要更多的磁盘 I/O 操作来检索大文本块，这可能会影响效率。

## 21 update 更新流程
在数据库层面，`UPDATE` 操作的执行过程涉及到数据库管理系统内部的一系列步骤。以下是一般的 `UPDATE` 操作流程：

1. **查询解析：**
   当执行 `UPDATE` 语句时，数据库管理系统首先对查询进行解析，确定需要更新的表、更新的列、更新的值，以及更新的条件。

2. **锁定记录：**
   在开始实际的更新之前，数据库系统可能会对需要更新的记录进行锁定，以确保在执行更新操作时其他事务不会干扰。锁的粒度可以是整个表、特定的行、或者特定的字段，这依赖于数据库系统的实现和事务隔离级别。

3. **执行更新操作：**
   数据库系统会根据 `UPDATE` 语句中指定的条件和新值来更新表中的记录。这通常涉及到在磁盘上实际的数据页中修改数据。

4. **事务日志记录：**
   在更新数据之前，数据库系统通常会将相关的信息记录到事务日志中。这样可以在发生故障时进行恢复。事务日志记录了 `UPDATE` 操作的详细信息，包括被更新的表、更新前的值、更新后的值等。

5. **事务提交：**
   如果更新操作发生在一个事务中，那么在所有更新操作完成之后，事务需要被提交。事务提交会将更新操作永久保存到数据库，使之对其他事务可见。如果发生了错误，可以选择回滚事务，使得更新操作不生效。

6. **解除锁定：**
   更新操作完成后，数据库会解除之前对记录的锁定，允许其他事务继续对这些记录进行操作。

这是一个一般性的 `UPDATE` 操作的执行流程。具体的实现可能会根据数据库系统的类型和配置有所不同。在高并发的情况下，事务管理和锁定策略变得尤为重要，以确保数据的一致性和完整性。

## 22 慢查询排除
慢查询排查是数据库性能优化中的一个重要步骤，通过找出慢查询并进行优化，可以提高数据库的响应速度。以下是一般性的数据库慢查询排查步骤：

1. **启用慢查询日志：**
   在数据库配置中启用慢查询日志，记录执行时间超过阈值的查询语句。在MySQL中，你可以修改`my.cnf`或者通过运行`SET GLOBAL slow_query_log = 'ON';`来启用慢查询日志。还可以配置慢查询日志的阈值，通常以秒为单位，例如`long_query_time = 1`表示记录执行时间超过1秒的查询。

2. **查看慢查询日志：**
   定期检查慢查询日志，找出执行时间较长的查询语句。可以使用`mysqldumpslow`工具来分析慢查询日志，例如：
   ```
   mysqldumpslow -t 10 -s t /path/to/slow_query.log
   ```
   这将显示执行时间最长的前10个查询。

3. **执行查询计划（EXPLAIN）：**
   对于慢查询，使用`EXPLAIN`语句来分析查询计划。这可以帮助你了解数据库是如何执行查询的，是否使用了索引，以及是否存在潜在的性能问题。例如：
   ```sql
   EXPLAIN SELECT * FROM your_table WHERE your_condition;
   ```

4. **优化查询语句：**
   根据`EXPLAIN`的结果，优化查询语句，确保它能够充分利用索引，避免全表扫描等低效操作。可能的优化包括添加合适的索引、重写查询语句、分析是否可以分批处理等。

5. **使用索引：**
   确保表中的列上有适当的索引。使用`SHOW INDEX FROM your_table;`可以查看表的索引信息。确保索引是合理的，并根据查询的需要创建新的索引。

通过这些步骤，你可以逐步找出慢查询的原因并进行优化，从而提高数据库的性能。

## 23 索引失效

在数据库中，虽然索引可以提高查询性能，但有一些情况下，查询可能会导致索引失效或性能变慢。以下是一些可能引起这种情况的常见情形：

1. **使用不等于（!=）或不包含（NOT IN）：** 当查询中使用不等于或不包含操作符时，索引可能会失效，因为这些操作符使得数据库无法有效使用索引进行快速检索。

   ```sql
   SELECT * FROM table_name WHERE column_name != 'value';
   ```

2. **模糊查询（LIKE '%...%')：** 在模糊查询中，以通配符开头的查询条件（如`LIKE '%value%'`）可能会导致索引失效，因为这样的查询很难进行优化。

   ```sql
   SELECT * FROM table_name WHERE column_name LIKE '%value%';
   ```

3. **使用函数或运算符：** 当在查询中使用函数或运算符时，索引可能会失效，因为数据库可能无法利用索引执行这些操作。

   ```sql
   SELECT * FROM table_name WHERE UPPER(column_name) = 'VALUE';
   ```

4. **OR条件：** 当查询中包含OR条件时，数据库可能无法有效使用索引，导致查询性能下降。

   ```sql
   SELECT * FROM table_name WHERE column_name = 'value' OR column_name = 'another_value';
   ```

## 24 timestamp和datetime区别

1. **`timestamp`：**
   - 通常表示一个特定时间点的距离某个基准时间的秒数或毫秒数。
   - 可以是整数型或浮点型，表示从某个特定时间点（通常是1970年1月1日午夜UTC，称为Epoch时间）开始的秒数或毫秒数。
   - 在某些数据库系统中，`timestamp` 类型可能还包含了时区信息。
2. **`datetime`：**
   - 表示一个完整的日期和时间，包括年、月、日、时、分、秒等。
   - 不同的数据库系统可能对 `datetime` 的存储格式有所不同，但通常是以固定的格式存储，例如'YYYY-MM-DD HH:MM:SS'。
   - `datetime` 类型通常包含时区信息，以确保正确地表示时间。

## 25 数据库各种join
在关系型数据库中，JOIN 是将两个或多个表中的行基于某个条件组合起来的操作。以下是常见的几种 JOIN 操作：

1. **INNER JOIN（内连接）**：
   - 只返回两个表中满足连接条件的行。
   - 语法：`SELECT * FROM table1 INNER JOIN table2 ON table1.column = table2.column;`

2. **LEFT JOIN（左连接）**：
   - 返回左表中所有的行，以及右表中满足连接条件的行。
   - 如果右表中没有匹配的行，返回 NULL 值。
   - 语法：`SELECT * FROM table1 LEFT JOIN table2 ON table1.column = table2.column;`

3. **RIGHT JOIN（右连接）**：
   - 返回右表中所有的行，以及左表中满足连接条件的行。
   - 如果左表中没有匹配的行，返回 NULL 值。
   - 语法：`SELECT * FROM table1 RIGHT JOIN table2 ON table1.column = table2.column;`

4. **FULL JOIN（全外连接或全连接）**：
   - 返回两个表中所有的行，无论是否满足连接条件。
   - 如果某个表中没有匹配的行，返回 NULL 值。
   - 语法：`SELECT * FROM table1 FULL JOIN table2 ON table1.column = table2.column;`

5. **CROSS JOIN（交叉连接）**：
   - 返回两个表中所有可能的组合，没有使用任何连接条件。
   - 语法：`SELECT * FROM table1 CROSS JOIN table2;`

6. **SELF JOIN（自连接）**：
   - 将表与自身进行连接，常用于查询具有层次结构的数据。
   - 语法：`SELECT * FROM table1 t1 INNER JOIN table1 t2 ON t1.column = t2.column;`



