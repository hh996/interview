## 1 事务的四大特性
原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）
- 原子性：指事务包含的所有操作要么全部成功，要么全部失败回滚。
- 一致性：指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。
- 隔离性：指一个事务的执行不能被其他事务干扰。每个事务应该以一种对其他事务隔离的方式执行，以防止并发执行时可能出现的数据不一致问题。隔离性通过使用锁和事务的隔离级别来实现
- 持久性：指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

## 2 数据库三大范式
- 第一范式：要求表中的每一列都是不可再分的基本数据项，而且每一行都不可重复，确保表中的每个字段必须是原子的
- 第二范式：一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分
- 第三范式：非主键列必须直接依赖于主键，不能存在传递依赖

**2NF和3NF的区别**
- 2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。
- 3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。

## 3 事务隔离级别
先了解下几个概念：脏读、不可重复读、幻读。
- 脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。
- 不可重复读：指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。
- 幻读：指的是在同一事务中的两次查询之间，由于其他事务插入或删除了数据，导致第二次查询看到了一些之前不存在或已经被删除的记录，就好像发生了幻觉一样

**不可重复读和脏读的区别**是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

四种隔离级别
- 读未提交（Read Uncommitted）：一个事务可以读取到另一个事务未提交的数据变更，存在脏读、不可重复读和幻读等并发问题
- 读已提交（Read Committed）：一个事务只能读取到已经提交的数据变更，可能出现不可重复读和幻读的问题
- 可重复读（Repeatable Read）：一个事务在其生命周期内多次查询同一数据，都将得到相同的结果，能出现幻读的问题
- 串行化（Serializable）：事务之间完全隔离，为了达到这个目标，系统通常会使用锁来阻止其他事务访问已经被当前事务锁定的数据

## 4 索引
索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。它可以比作一本字典的目录，可以帮你快速找到对应的记录。

优点：加快数据查找的速度。 缺点：占用物理空间；会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引

数据结构：B+树和哈希表
- 哈希索引不支持排序，因为哈希表是无序的。
- 哈希索引不支持范围查找。
- 哈希索引不支持模糊查询及多列索引的最左前缀匹配。
- 因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点

索引类型

按照底层存储方式角度划分
- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引

按照应用维度划分
- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

## 5 B+树比B树更适合实现数据库索引
- B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当
- B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。**减少更多的I/O支出**。
- B+树叶子结点均为索引，方便扫库；B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫

## 6 聚簇索引与非聚簇索引
聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。查询速度非常快；依赖于有序的数据，更新代价大
非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。更新代价比聚簇索引要小；但是依赖于有序的数据，可能会二次查询（当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询）

## 7 最左前缀匹配原则
使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 >、< ）才会停止匹配。对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

## 8 MVCC（多版本并发控制方法）
对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本
- undo log : undo log 用于记录某行数据的多个版本的数据。
- read view 和 隐藏字段 : 用来判断当前版本数据的可见性。

## 9 MySQL有哪些锁
按锁粒度分类：
- 行级锁：只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大 。行级锁的类型主要有三类： 
  - Record Lock，记录锁，也就是仅仅把一条记录锁上；
  - Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
  - Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
- 页级锁：速度快，但冲突多，一次锁定相邻的一组记录
- 表级锁：粒度最大的一种锁，对当前操作的整张表加锁，它实现简单，资源消耗较少
按锁级别分类：
- 共享锁又称读锁：读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改
- 排他锁又称写锁：事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的封锁
- 意向锁是表级锁：在一个事务中揭示下一行将要被请求锁的类型，InnoDB 中的两个表锁
   - 意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁
   - 意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

## 10 InnoDB和MyISAM存储引擎
InnoDB支持行级别的锁 提供事务支持 实现了 SQL 标准定义了四个隔离级别 支持外键 支持MVCC 是聚簇索引
- InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。
- MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。
- MyISAM 不支持外键，而 InnoDB 支持。
- MyISAM 不支持 MVCC，而 InnoDB 支持。
- 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。InnoDB是聚簇索引，MyISAM是非聚簇索引
- MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。InnoDB 的性能比 MyISAM 更强大


## 11 乐观锁和悲观锁
MySQL并发控制的策略
- 悲观锁的思想是在整个数据操作过程中，将数据锁定，以防止其他事务的干扰。
- 乐观锁的思想是认为在大多数情况下，事务之间的冲突是很少发生的。因此，乐观锁不主动加锁，而是在事务提交时检查是否有其他事务对数据进行了修改

## 12 MySQL字段类型
- 数值类型：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
- 字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
- 日期时间类型：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP

## 13 CHAR 和 VARCHAR 的区别
CHAR 是定长字符串，VARCHAR 是变长字符串

## 14 DECIMAL 和 FLOAT/DOUBLE 的区别
DECIMAL 和 FLOAT 的区别是：DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。

## 15 DATETIME 和 TIMESTAMP 的区别
DATETIME 类型没有时区信息，TIMESTAMP 和时区有关

## 16 Boolean 类型如何表示
MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值

## 17 NULL 和 '' 的区别（为什么 MySQL 不建议使用 NULL 作为列默认值）
- ''的长度是 0，是不占用空间的，而NULL 是需要占用空间的
- 查询 NULL 值时，必须使用 IS NULL 或 IS NOT NULLl 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而''是可以使用这些比较运算符的

## 18 SQL 优化
索引、JOIN、LIMIT

## 19 char varchar text区别
CHAR：
存储固定长度的字符数据。
如果存储的字符串长度小于指定的长度，将使用空格进行填充。
非变长，占用的存储空间是指定长度的固定大小。
```sql
CREATE TABLE example_char (
    char_column CHAR(10)
);
```
VARCHAR：
存储可变长度的字符数据。
只存储实际字符串的长度，不使用填充字符。
需要额外的存储空间来存储字符串的长度信息。
```sql
Copy code
CREATE TABLE example_varchar (
    varchar_column VARCHAR(255)
);
```
TEXT：
用于存储大量的文本数据，长度可以很大。
通常用于存储文档、文章或其他较大的文本块。
不需要指定固定的长度。
```sql
Copy code
CREATE TABLE example_text (
    text_column TEXT
);
```

## 20 char varchar text检索效率
CHAR：  
由于是固定长度，CHAR 类型的字段可能在某些情况下提供更快的检索速度。这是因为数据库引擎可以更容易地计算出每个记录的偏移量。
当查询涉及到固定长度的匹配时，CHAR 可能更为高效。

VARCHAR：  
VARCHAR 类型的字段存储实际的字符串长度，因此在存储和检索时可能需要更少的空间。  
VARCHAR 在处理可变长度的字符串时更灵活，但这也可能导致在某些情况下稍微降低检索速度。 

TEXT：  
TEXT 类型通常用于存储大块的文本数据，如文章或文档。在一些情况下，可能会牺牲一些检索速度以获取更大的存储容量。
对于 TEXT 类型，数据库引擎可能需要更多的磁盘 I/O 操作来检索大文本块，这可能会影响效率。

## 21 update 更新流程
在数据库层面，`UPDATE` 操作的执行过程涉及到数据库管理系统内部的一系列步骤。以下是一般的 `UPDATE` 操作流程：

1. **查询解析：**
   当执行 `UPDATE` 语句时，数据库管理系统首先对查询进行解析，确定需要更新的表、更新的列、更新的值，以及更新的条件。

2. **锁定记录：**
   在开始实际的更新之前，数据库系统可能会对需要更新的记录进行锁定，以确保在执行更新操作时其他事务不会干扰。锁的粒度可以是整个表、特定的行、或者特定的字段，这依赖于数据库系统的实现和事务隔离级别。

3. **执行更新操作：**
   数据库系统会根据 `UPDATE` 语句中指定的条件和新值来更新表中的记录。这通常涉及到在磁盘上实际的数据页中修改数据。

4. **事务日志记录：**
   在更新数据之前，数据库系统通常会将相关的信息记录到事务日志中。这样可以在发生故障时进行恢复。事务日志记录了 `UPDATE` 操作的详细信息，包括被更新的表、更新前的值、更新后的值等。

5. **事务提交：**
   如果更新操作发生在一个事务中，那么在所有更新操作完成之后，事务需要被提交。事务提交会将更新操作永久保存到数据库，使之对其他事务可见。如果发生了错误，可以选择回滚事务，使得更新操作不生效。

6. **解除锁定：**
   更新操作完成后，数据库会解除之前对记录的锁定，允许其他事务继续对这些记录进行操作。

这是一个一般性的 `UPDATE` 操作的执行流程。具体的实现可能会根据数据库系统的类型和配置有所不同。在高并发的情况下，事务管理和锁定策略变得尤为重要，以确保数据的一致性和完整性。

## 22 慢查询排除
慢查询排查是数据库性能优化中的一个重要步骤，通过找出慢查询并进行优化，可以提高数据库的响应速度。以下是一般性的数据库慢查询排查步骤：

1. **启用慢查询日志：**
   在数据库配置中启用慢查询日志，记录执行时间超过阈值的查询语句。在MySQL中，你可以修改`my.cnf`或者通过运行`SET GLOBAL slow_query_log = 'ON';`来启用慢查询日志。还可以配置慢查询日志的阈值，通常以秒为单位，例如`long_query_time = 1`表示记录执行时间超过1秒的查询。

2. **查看慢查询日志：**
   定期检查慢查询日志，找出执行时间较长的查询语句。可以使用`mysqldumpslow`工具来分析慢查询日志，例如：
   ```
   mysqldumpslow -t 10 -s t /path/to/slow_query.log
   ```
   这将显示执行时间最长的前10个查询。

3. **执行查询计划（EXPLAIN）：**
   对于慢查询，使用`EXPLAIN`语句来分析查询计划。这可以帮助你了解数据库是如何执行查询的，是否使用了索引，以及是否存在潜在的性能问题。例如：
   ```sql
   EXPLAIN SELECT * FROM your_table WHERE your_condition;
   ```

4. **优化查询语句：**
   根据`EXPLAIN`的结果，优化查询语句，确保它能够充分利用索引，避免全表扫描等低效操作。可能的优化包括添加合适的索引、重写查询语句、分析是否可以分批处理等。

5. **使用索引：**
   确保表中的列上有适当的索引。使用`SHOW INDEX FROM your_table;`可以查看表的索引信息。确保索引是合理的，并根据查询的需要创建新的索引。

通过这些步骤，你可以逐步找出慢查询的原因并进行优化，从而提高数据库的性能。
优化




