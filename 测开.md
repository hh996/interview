## 软件测试的流程

- 测试需求分析阶段：阅读需求，理解需求，分析需求点，参与需求评审会议
- 测试计划阶段：参考软件需求编写测试计划，内容包括测试范围（来自需求文档），进度安排，人力物力的分配，整体测试策略的制定。
- 测试设计阶段：参考需求文档编写测试用例，用例编写完成之后会进行评审。
- 测试执行阶段：搭建测试环境，执行测试，bug管理直到测试结束
- 测试评估阶段：出测试报告，确认是否可以上线

## 常见的测试模型

瀑布模型

将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品

优点:
1）各阶段划分清晰
2）强调计划与需求分析
3）适合需求稳定的产品开发
缺点:
1）**单一流程**，不可逆
2）风险显露得晚，纠正机会少
3）测试只是其中一个阶段，**缺乏全过程测试思想**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810210722901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FyaWF6bQ==,size_16,color_FFFFFF,t_70)



V模型

它通过开发和测试同时进行的方式来缩短开发周期，提高开发效率。
优点：相对于瀑布模型，**V模型测试能够尽早的进入到开发阶段**。
缺点：虽然测试尽早的进入到开发阶段，但是真正进行软件测试是在编码之后，这样**忽视了测试对需求分析，不能使用需求的变动**，系统设计的验证，时间效率上也大打折扣。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810213219195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FyaWF6bQ==,size_16,color_FFFFFF,t_70)

W模型

**W模型增加了软件开发各阶段中同步进行的验证和确认活动，需求的变更和调整，依旧不方便**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810214655498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FyaWF6bQ==,size_16,color_FFFFFF,t_70)

## 测试方法分类

### 按测试阶段划分

- 单元测试：单元测试属于**白盒测试**，单元测试是最微小规模的测试，是对软件中的单元模块进行测试，测试的是某个功能或代码块。
- 集成测试：集成测试属于**灰盒测试**，集成测试又称为组装测试，就是在单元测试的基础上，对单元模块之间的接口进行测试。
- 系统测试：系统测试属于**黑盒测试**，主要测试系统是否符合需求，包括对功能、性能，以及软件所运行的软硬件环境进行测试。
- 验收测试：验收测试是基于客户或最终用户的规格书的最终测试，或基于用户一段时间的使用后，看软件是否满足客户要求。一般从功能、用户界面、性能、业务关联性进行测试。
- 回归测试：回归测试是指在发生修改之后重新测试，目的是验证新增的功能是否引入新的问题，旧的缺陷是否修复成功。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。

### 验收测试中的测试方法

- α测试：在软件发布前，由内部开发机构人员来模拟潜在用户开展的测试，则称为α测试。
- β测试：β测试是在软件公司外部展开的测试，可以由非专业的测试人员执行的测试，例如由具有代表性的用户群来进行测试。

### 按是否查看程序内部结构划分

- 白盒测试：对软件内部的逻辑结构进行详细检查，对程序的所有逻辑进行测试。
- 黑盒测试：把测试对象看成一个黑盒子，不需要考虑程序内部的逻辑结构，只需要依照程序的需求规格说明书，检查程序功能是否能够实现即可。黑盒测试又分为功能测试和性能测试。功能测试检查实际软件的功能是否符合用户的需求。包括逻辑功能测试、界面测试、易用性测试和兼容性测试。性能测试主要有时间性能和空间性能两种。其中，时间性能主要指软件的一个具体事务的响应时间，而空间性能主要指软件运行时所消耗的系统资源。
- 灰盒测试：是介于白盒测试和黑盒测试之间的一种测试，不仅关注输出输入情况，也关注程序内部的逻辑。

### 功能测试中的测试方法

- **冒烟测试：对软件基本功能的测试**
- 兼容性测试：兼容测试主要是检查软件在不同的平台上是否可以正常的运行，即是通常说的软件的可移植性。兼容性测试属于非功能性测试，我们拿到一个产品时，应优先保证功能性测试的验证，再去兼顾其它非功能性测试。

### 性能测试中的测试方法

- 负载测试：负载测试是通过改变系统负载方式、逐渐增加负载等来发现系统中所存在的性能问题。负载测试是一种测试方法，可以为性能测试、压力测试所采用。
- 压力测试：压力测试通常是在高负载情况下来对系统的稳定性进行测试，更有效地发现系统稳定性的隐患和系统在负载峰值的条件下功能隐患等。

### 按是否运行程序划分

- 静态测试：静态测试指测试不运行的部分，只是静态地检查程序代码、界面或文档可能存在的错误的过程。例如测试产品说明书，对此进行检查和审阅.。
- 动态测试：动态测试是指通过运行软件来检验软件的动态行为和运行结果的正确性。具体操作就是输入相应的测试数据，检查输出结果和预期结果是否相符的过程。

### 按测试执行方式划分

- 手动测试：人工执行测试
- 自动化测试：软件测试自动化，目的是节省人力、时间或硬件资源，提高测试效率



## 黑盒测试中测试用例的设计方法有哪些

有基于需求的设计方法、等价类划分、边界值分析、因果图

### 等价类划分法

- 定义：依据需求将输入划分为若干等价类，从等价类中选定一个测试用例，如果该测试用例通过，则表明整个等价类通过测试。
- 适用场景：对于等价类这个方法，一般适用于有无限多种输入，我们不可能完成穷举测试，等价类可以使我们用较少的测试用例尽可能多的将功能覆盖。
- 一般划分为：有效等价类、无效等价类。有效等价类：有意义的输入构成的集合，对于需求规格说明书是合法的；无效等价类：不满足需求的集合。

### 边界值分析法

- 定义：边界值法是对输入数据的边界测试，一般来说边界值法是对等价类划分后的补充。
- 举例： 对于设定密码的测试，要求密码必须为6-15位 分析过程：有效等价类为>=6 && <=15 无效等价类为：<6 || >15 设定边界值：5、6、10、15、16

> - 解释：
> - 6和15作为有效等价类中的内容，又是边界值，可以判定有效等价类的内容是否满足要求
> - 但是6和15又很特殊，它不仅代表了有效等价类，还代表了边界值，所以我们选定一个普通的有效等价类作为一个测试用例，如：10
> - 5和16作为无效等价类中的内容，又是边界值（比4或者17更具有代表性），可以判定无效等价类的内容

### 因果图

- 定义：因果图是从需求中找出因（输入条件）和果（输出或程序改变的状态），通过因果图转化为判定表。
- 使用因果图法设计测试用例的步骤：
  1. 确定软件规格(需求)中的原因和结果
  2. 确定原因和结果之间的逻辑关系
  3. 确定因果图中的各个约束(constraints)
  4. 画出因果图并转换为判定表
  5. 根据判定表设计测试用例



## 灰度测试和A/B测试是什么？它们之间有什么区别？

灰度测试

- 灰度测试：**在某项应用正式发布前**，选择特定人群试用，逐步扩大其试用者数量，以便及时发现和纠正其中的问题。(做灰度测试需要选择适合的用户，需要基于随机原则)
  例如：某应用升级了视频资源的播放格式，但不知道新版本是否有问题。那么该应用可以通过配置下发，控制一部分用户的应用去播放新格式的视频。然后通过监控来观测播放成功率和卡顿率等，一旦有问题会立即回滚(新版本回滚至旧版本)。
- A/B测试：AB测试是为某个应用制作两个（A/B）或多个（A/B/n）版本，在同一时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机地访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。
  例如：某应用换皮肤，可以把两种待选皮肤都投入市场，看哪种皮肤的按钮用户点击量大，用户停留时长高。

区别：

- **灰度测试本质上是上线前的测试**，收集用户的反馈。**A/B测试本质上是上线后的测试**，收集用户的反馈。
- AB的两种功能都是可用的，投放的用户群体无差别，让用户选择更受欢迎的功能。目标不明确，后期可能是A上线，也可能是B上线。灰度版本未必是可用的，或者说没有严重bug的，投放的客户群体可能被选择和约束（例如只投放安卓低端机），由监控确定是否有问题，目标明确，只要灰度版本没问题，就会继续放量上线，直到全量。

## 白盒测试中测试用例的设计方法有哪些？

有逻辑覆盖法和基本路径法，其中逻辑覆盖法分为：语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖与路径覆盖。

- 语句覆盖：在测试时，首先设计若干个测试用例，然后运行被测程序，使程序中的每个可执行语句至少执行一次。
- 分支覆盖：确保每个分支语句的每个可能的条件都被覆盖

- 条件覆盖：确保每个条件语句的每个可能的真和假的情况都被覆盖。

- 路径覆盖：确保每个可能的代码执行路径都被覆盖。



# 接口测试

## 什么是接口测试？

接口测试，其实就是验证接口内部处理逻辑是否正确。既要保证单接口的正确性，也要保证接口的业务逻辑正确性，主要体现在两方面：

- 输入正确的测试数据，验证接口正常处理后返回的数据是否正确，验证内容包括返回数据的数据结构及数据内容。
- 输入异常的测试数据，验证接口能否正确处理异常数据并返回特定提示，是否合理，是否健壮

## 接口测试的目的是什么？

- 可以让测试工程师尽早介入测试，也就是测试左移。
- 可以在项目初期就能发现系统更深层次的问题，也就是代码层的问题，进而降低问题的修复成本。

## 接口测试的必要性？

1. 接口测试直接测试后端服务，更加接近服务器上运行的代码程序，也更能发现影响范围广泛的 Bug。
2. 接口自动化脚本的维护成本更低。因为接口的改动概率远低于界面 UI 的改动概率，因此，接口自动化测试脚本的维护成本远低于 UI 自动化测试脚本。

可以结合 Jenkins，构建接口自动化测试，达到持续集成的效果，还能自动发送测试报告到组内成员邮箱
